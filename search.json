[{"title":"Object的方法","url":"/Object的方法/","content":"## 定义属性 ##\n定义一个对象，必须明确属性名和对应的值，即使属性名和声明的变量名一样（var a = {obj：obj}），ES6及后续版本允许我们用短的代码声明对象，用于将对象的属性分配给与属性同名的变量\n```\nvar x = 1, y = 2;\nvar object = {\n x: x,\n y: y \n};\nconsole.log(object.x); //output 1\n```\n但是ES6之后，你可以这么做\n```\nlet x = 1, y = 2;\nlet object = { x, y };\nconsole.log(object);    // {x: 1, y: 2}\nconsole.log(object.x);  // //output 1\n```\n\n## 计算属性名 ##\n对象属性支持计算属性名。其允许在[]中放入表达式，计算结果可以当做属性名。\n```\nlet object = {\n  [\"first\" + \"Name\"]: \"Eden\",\n};\n//extract\nconsole.log(object[\"first\" + \"Name\"]); \n//Output \"Eden”\nconsole.log(object);\n//Output \"{ firstName: 'Eden' }”\n```\n## Object.is() ##\n`Object.is()`它用来比较两个值是否严格相等，与严格比较运算符（ === ）的行为基本一致，是在三等号判断的基础上新增了两个不同之处。\n`Object.is()不同之处只有两个：一是+0不等于-0，二是NaN等于自身。`\n语法：\n`Object.is(value1, value2);`\n传入两个要比较的值，判断是否相同，全等的话返回true，不全等返回false。\n![alt](/images/objectIs.png)\n三等号既要判断值的类型是否相等，还要判断引用地址是否相等。所以`Object.is()`也是，在判断对象和数组这些引用类型的数据是不相等的。\n\n## Object.assign() ##\nObject.assign()方法用于对象的合并，将源对象（ source ）的所有可枚举属性，复制到目标对象（ target ）。\n![alt](/images/objectAssign.png)\n**注意：**\n这里是`浅拷贝`！！\n如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会`覆盖`前面的属性！！\n```\nlet obj1 = {a:{b:1},b:22};\nlet obj2 = Object.assign({b:11},obj1);\nconsole.log(obj2); // {b:22,a:{b:1}}\n//修改obj1的属性值\nobj1.a.b = 2;\n//这时会影响到obj2的属性值，这就是浅拷贝导致的\nconsole.log(obj2.a.b); // 2\n\n```\n\n## Object.keys()、Object.values()、Object.entries() ##\n`Object.keys()`方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（ enumerable ）属性的`键名`数组。\n\n`Object.values()`方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（ enumerable ）属性的`键值`数组。\n\n`Object.entries()`方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（ enumerable ）属性的`键值对`数组。\n```\nlet obj = {name:\"winne\",age:22};\nlet objKeys = Object.keys(obj);\nlet objValues = Object.values(obj);\nlet objItem = Object.entries(obj);\n\nconsole.log(objKeys);   //[\"name\",\"age\"]\nconsole.log(objValues); //[\"winne\",22]\nconsole.log(objItem);   //[[\"name\",\"winne\"],[\"age\",22]]\n\n```\n取出了想要的部分，我们就可以遍历数组取得每一项了。\n```\n\n//for..of遍历\n\nfor( let key of objKeys){\n    console.log(key)\n}\n//name\n//age\n\n//forEach遍历\nobjKeys.forEach(function(item,index){\n    console.log(item,index);\n})\n//name  0\n//age   1\n```","tags":["ES6"],"categories":["ES6"]},{"title":"Array方法","url":"/Array方法/","content":"\n## forEach ##\n\n```\n通过下标取值,forEach是数组的方法不能break，continue，\n\nlet arr = ['a','b','c'];\nlet forEachRetrun = arr.forEach(function (item,index){\n\tconsole.log(item,index);\t\n});\n```\n\n## map ##\n```\nmap映射,对数组的每一项都运行给定的函数，返回每次函数调用的结果组成一个新数组\nmap的返回值是一个数组，数组的个数和操作的数组一样\nmap返回的数组的每一项是回调函数的返回值\n\nvar numbers = [1, 5, 10, 15];\nvar doubles = numbers.map(function(item, index) {\n  console.log(item, index)\n  return item * 2;\n});\nconsole.log(doubles)\n// doubles is now [2, 10, 20, 30]\n// numbers is still [1, 5, 10, 15]\n\n```\n\n### Demo ###\n将数组中的数据拼接成为字符串\n\n```\nlet arr = [\n\t{\n\t\tname:'leo1'\n\t},\n\t{\n\t\tname:'leo2'\n\t}\n];\nlet str = '';\nfor( var i = 0; i < arr.length; i++ ){\n\tstr += `<li>${arr[i].name}</li>`\n}\n\nconsole.log(str);\n// <li>leo1</li><li>leo2</li>\n\nlet arrStr = arr.map(function (item){\n\treturn `<li>${item.name}</li>`\t\n}).join('')\n\nconsole.log(arrStr);\n```\n\n## filter ##\n对数组的每一项都运行给定的函数，返回 结果为 ture 的项组成的数组\n```\nvar numsArr = [1,2,3,4,5,6,7,8];\n\n// 小于5的数，放在数组中\nvar empty = []\nfor( var i = 0; i < numsArr.length; i++ ){\n\tif(numsArr[i] < 5){\n\t\tempty.push(numsArr[i])\n\t}\n}\nconsole.log(empty);\n\nlet filetrReturn = numsArr.filter(function (item,index){\n\tconsole.log(item,index);\n\treturn item < 5;\t\n})\nconsole.log(filetrReturn);\n\nlet arr = [\n\t{\n\t\tname:'leo1',\n\t\tage:30\n\t},\n\t{\n\t\tname:'leo2',\n\t\tage:40\n\t},\n\t{\n\t\tname:'leo1',\n\t\tage:20\n\t},\n\t{\n\t\tname:'leo2',\n\t\tage:60\n\t}\n];\n\n\nlet newArr = arr.filter(function (item){\n\treturn item.age > 20\t\n})\n\nconsole.log(newArr);\n\n```\n\n## every ##\n对数组的每一项都运行给定的函数，每一项都返回 ture,则返回 true，如果有一个不符合，就返回false.\n```\nlet arr = [1,2,3,4,5,6];\n\nlet bl = arr.every(function (item){\n\treturn item > -1\t\n})\nconsole.log(bl);\n// true\n```\n\n## some ##\n对数组的每一项都运行给定的函数，任意一项都返回 ture,则返回 true\n```\nlet arr = [1,2,3,4,5,6];\nlet bl2 = arr.some(function (item){\n\treturn item > 5\t\n})\n\nconsole.log(bl2);\n// true\n```\n\n## reduce ##\nArray.reduce(callback[,初始值])\tcallback会接受两个参数item1 item2、没给reduce写初始值，callback会默认第一次接受数组中的前两个值。\n\n**执行callback**\n  - 第一次：接收数组中前两个值 \n  - 第二次开始，第一个参数是上一次执行的回调函数的返回值，第二个参数从数组中取\n\t。。。。\n\n```\n数组中的数字累加\nvar arr = [1,2,3,4,5,6,7];\nvar n = 0;\nfor( var i = 0; i < arr.length; i++ ){\n\tn += arr[i];\n}\nconsole.log(n); // 28\n\nvar n = arr.reduce(function (item1,item2){\n\tconsole.log(item1,item2);\t\n\treturn item1 + item2\n},100)\n\nconsole.log(n);  // 128\n\nvar arr = [{\n\tage: 30,\n\theight: 180\n},{\n\tage: 30,\n\theight: 180\n},{\n\tage: 30,\n\theight: 180\n},{\n\tage: 30,\n\theight: 180\n}];\nvar m = arr.reduce(function (item1,item2){\n\tconsole.log(item1,item2);\n\treturn {\n\t\tage: item1.age + item2.age,\n\t\theight: item1.height + item2.height\n\t}\n},{\n\tage: 0,\n\theight: 1000\n})\n\nconsole.log(m); // {age: 120, height: 1720}\n\n```\n**reduce方法简单实现数组中对象去重**\njs数组的reduce方法，接收一个函数（必须）和指定的初始值（非必须）作为参数，函数有三个参数，分别为初始值，当前项，当前数组，进行累加或者累积操作，初始值为每次累加或者累计后的结果\n**注意：在ie9一下的浏览器中，并不支持该方法 ！**\n语法：`arr.reduce(fn(pre,cur,arr){},[initialValue])`\n```\nvar arr = [\n　　{value:'苹果',id:1},\n　　{value:'香蕉',id:2},\n　　{value:'苹果',id:3}\n ]\nvar hash = {};\narr = arr.reduce((item, next) =>{\n   hash[next.value] ? '' : hash[next.value] = true && item.push(next); \n   return item\n}, [])\nconsole.log(arr)\n\n//  {value: \"苹果\", id: 1} {value: \"香蕉\", id: 2}\n```\n\n## find ##\n传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它，并且终止搜索。\n```\nvar arr = [1,2,3,4,5,6,7];\nvar item = arr.find(item => {\n\treturn item  > 4\n})\nconsole.log(item);  // 5\n```\n\n## findIndex ##\n传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它的下标，终止搜索。\n```\nvar arr = [1,2,3,4,5,6,7];\nvar index = arr.findIndex(item => {\n\treturn item  > 4\n})\nconsole.log(index);  // 4\n```\n## from ##\n将类似数组的对象（array-like object）和可遍历（iterable）的对象转为真正的数组\n```\nconst bar = [\"a\", \"b\", \"c\"];\nArray.from(bar);\n// [\"a\", \"b\", \"c\"]\n\nArray.from('foo');\n// [\"f\", \"o\", \"o\"]\n```\n## of ##\n用于将一组值，转换为数组。这个方法的主要目的，是弥补数组构造函数 Array() 的不足。因为参数个数的不同，会导致 Array() 的行为有差异。\n```\nArray()             // []\nArray(3)           // [, , ,]\nArray(3, 11, 8)    // [3, 11, 8]\nArray.of(7);       // [7]\nArray.of(1, 2, 3); // [1, 2, 3]\n\nArray(7);          // [ , , , , , , ]\nArray(1, 2, 3);    // [1, 2, 3]\n```\n## includes ##\n判断数组中是否存在该元素，参数：查找的值、起始位置，可以替换 ES5 时代的 indexOf 判断方式。indexOf 判断元素是否为 NaN，会判断错误。\n```\nvar a = [1, 2, 3];\na.includes(2); // true\na.includes(4); // false\n```\n## keys() 返回迭代器：返回键值对的key ##\n```\n// 定义一个 Array 对象\nlet arr = [\"a\", \"b\", \"c\"];\n\n// 定义一个 Object 对象\nlet obj = { foo: \"bar\", baz: 42 };\n\n// 定义一个  类数组 对象 \nlet ArrayLike = { 0 : \"a\", 1 : \"b\", 2 : \"c\"};\n\n// 类数组 对象, 随机 key 排序 \nlet anObj = { 100: 'a', 2: 'b', 7: 'c' }; \n\n/* getFoo 是个不可枚举的属性 */ \nvar my_obj = Object.create({}, {\n     getFoo : { value : function () { return this.foo } }\n }\n);\nmy_obj.foo = 1;\n\n// 打印结果\nconsole.log(Object.keys(arr));       // ['0', '1', '2']\nconsole.log(Object.keys(obj));       // [\"foo\",\"baz\"]\nconsole.log(Object.keys(ArrayLike));     // ['0', '1', '2']\nconsole.log(Object.keys(anObj));   // ['2', '7', '100']\nconsole.log(Object.keys(my_obj)); // ['foo']\n\n```\n## 求数组中的最大值&求数字中的最小值 ##\n\n虽然Math.min()能取到最小值,Math.max()能取到最大值,但是不支持数组。\n```\nMath.min.apply(obj,args);\n```\n这个obj对象将代替Function类里this对象，第二个传进来的是数组\n```\nMath.max.apply(obj,parms);\n```\n这个obj对象将代替Function类里this对象，第二个传进来的是参数\n```\nvar obj = Math.max.apply(obj,arr)\nconsole.log(obj); // 100\n\nvar arr = [1,2,3,4,9,100,0];\nconsole.log(Math.max(...arr));\nconsole.log(Math.min(...arr));\n\n```\n## Array常用方法 ##\n```\nArray 对象属性\n\nconstructor 返回对创建此对象的数组函数的引用。\nlength 设置或返回数组中元素的数目。\nprototype 使您有能力向对象添加属性和方法。\n\nArray 对象方法\n\nconcat() 连接两个或更多的数组，并返回结果。\njoin() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。\npop() 删除并返回数组的最后一个元素。  \nshift() 删除并返回数组的第一个元素\npush() 向数组的末尾添加一个或更多元素，并返回新的长度。\nunshift() 向数组的开头添加一个或更多元素，并返回新的长度。\nreverse() 颠倒数组中元素的顺序。\nslice() 从某个已有的数组返回选定的元素\nsort() 对数组的元素进行排序\nsplice() 删除元素，并向数组添加新元素。\ntoSource() 返回该对象的源代码。\ntoString() 把数组转换为字符串，并返回结果。\ntoLocaleString() 把数组转换为本地数组，并返回结果。\nvalueOf() 返回数组对象的原始值\n```","tags":["ES6"],"categories":["ES6"]},{"title":"vue生命周期","url":"/vue生命周期/","content":"\n\n<escape><!-- more --></escape>\n\n"},{"title":"SASS入门","url":"/SASS入门/","content":"\n\n<escape><!-- more --></escape>\n\n","tags":["vue"],"categories":["vue"]},{"title":"UI组件","url":"/UI组件/","content":"\n\n<escape><!-- more --></escape>\n\n","tags":["vue"],"categories":["vue"]},{"title":"父子组件传值","url":"/父子组件传值/","content":"在Vue中，父组件通过`prop`给子组件下发数据，子组件通过事件`$emit`给父组件发送信息。\n\n\n<escape><!-- more --></escape>\n\n\n\n## 父组件向子组件传值 ##\n\n```\n<!-- 父组件 -->\n<template>\n  <div>\n    <certificate-input :p_model='pname' :xi_model=\"xiname\" :arr=\"arr\" :break=\"break\" :obj=\"obj\"></certificate-input>\n  </div>\n</template>\nimport CertificateInput from '../common/CertificateInput.vue'\nexport default {\n    name: '',\n    components: {\n        CertificateInput \n    },\n    data() {\n      return {\n        pname:\"\",\n        xiname:123,\n        arr:[],\n        break: false,\n        obj: {}\n    }     \n}\n```\n```\n<!-- 子组件 -->\nexport default {\n  props: {\n    pModel: {\n      type: String,\n      default: 'hello world'\n    },\n    xiModel: {\n      type: Number,\n      default: 0\n    },\n    break: {\n      type: Boolean,\n      default: true\n    },\n    arr: {\n      type: Array,\n      default: () => {\n        return []\n      }\n    },\n    arr: {\n      type: Object,\n      default: () => {\n        return {}\n      }\n    }\n  }\n}\n```\n## 子组件向父组件传值 ##\n每个Vue实例都实现了事件接口：使用`$on(evntName)`监听事件；使用`$emit(eventName,optionalPayload)`触发事件。\n```\n<!-- 父组件 -->\n<template>\n    <div class=\"test\">\n      <test-com @childFn=\"parentFn\"></test-com>\n      <br/> \n      子组件传来的值 : {{message}}\n    </div>\n</template>\n\n<script>\nexport default {\n    // ...\n    data: {\n        message: ''\n    },\n    methods: {\n       parentFn(payload) {\n        this.message = payload;\n      }\n    }\n}\n</script>\n```\n```\n<!-- 子组件 -->\n<template> \n<div class=\"testCom\">\n    <input type=\"text\" v-model=\"message\" />\n    <button @click=\"click\">Send</button>\n</div>\n</template>\n<script>\nexport default {\n    // ...\n    data() {\n        return {\n          // 默认\n          message: '我是来自子组件的消息'\n        }\n    },\n    methods: {\n      click() {\n            this.$emit('childFn', this.message);\n        }\n    }    \n}\n</script>\n```\n## .sync修饰符 ##\n作为一个编译时的语法糖存在。它会被扩展为一个自动更新父组件属性的 v-on 监听器。\n```\n<comp :foo.sync=\"bar\"></comp>\n```\n会被扩展为：\n\n```\n<comp :foo=\"bar\" @update:foo=\"val => bar = val\"></comp>\n```\n\n当子组件需要更新 foo 的值时，它需要显式地触发一个更新事件：\n\n```\nthis.$emit('update:foo', newValue)\n```","tags":["vue"],"categories":["vue"]},{"title":"vuex","url":"/vuex/","content":"Vuex 是一个专为 Vue.js 应用程序开发的`状态管理模式`，可以帮助我们管理共享状态。在具有VueX的Vue项目中，我们只需要把这些值定义在VueX中，即可在整个Vue项目的组件中使用。\n\n在Vue项目开发中，需要监控项目中得各种值，为了提高效率，Vue提供了一款浏览器扩展——`VueDevtools`。\n\n\n<escape><!-- more --></escape>\n\n\n## 使用 ##\n### 初始化`store`下`index.js`中的内容 ###\n```\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\n//挂载Vuex\nVue.use(Vuex)\n\n//创建VueX对象\nconst store = new Vuex.Store({\n    state:{\n        //存放的键值对就是所要管理的状态\n        name:'helloVueX'\n    }\n})\n\nexport default store\n```\n### 将store挂载到当前项目的Vue实例当中去 ###\n打开main.js\n```\nimport Vue from 'vue'\nimport App from './App'\nimport router from './router'\nimport store from './store'\n\nVue.config.productionTip = false\n\n/* eslint-disable no-new */\nnew Vue({\n  el: '#app',\n  router,\n  store,  //store:store 和router一样，将我们创建的Vuex实例挂载到这个vue实例中\n  render: h => h(App)\n})\n```\n### 在组件中使用Vuex ###\n```\n<template>\n    <div id='app'>\n        name:\n        <h1>{{ $store.state.name }}</h1>\n    </div>\n</template>\n```\n或者要在组件方法中使用\n```\n...,\nmethods:{\n    add(){\n      console.log(this.$store.state.name)\n    }\n},\n...\n```\n## VueX中的核心内容 ##\n在VueX对象中，其实不止有state,还有用来操作state中数据的方法集，以及当我们需要对state中的数据需要加工的方法集等等成员。\n\n**成员列表：**\n\n  - state 存放状态\n  - mutations state成员操作\n  - getters 加工state成员给外界\n  - actions 异步操作\n  - modules 模块化状态管理\n\n### VueX的工作流程 ###\n\n首先，Vue组件如果调用某个VueX的方法过程中需要向后端请求时或者说出现异步操作时，需要`dispatch VueX`中`actions`的方法，以保证数据的同步。可以说，`action`的存在就是为了让`mutations`中的方法能在异步操作中起作用。\n\n如果没有异步操作，那么我们就可以直接在组件内提交状态中的`Mutations`中自己编写的方法来达成对`state`成员的操作。不建议在组件中直接对state中的成员进行操作，这是因为直接修改(例如：this.$store.state.name = 'hello')的话不能被VueDevtools所监控到。\n\n最后被修改后的state成员会被渲染到组件的原位置当中去。\n\n![alt](/images/vuex.png)\n\n### Mutations ###\nmutations是操作state数据的方法的集合，比如对该数据的修改、增加、删除等等。\nmutations方法都有默认的形参：(`[state] [,payload]`)\n\n  - state是当前VueX对象中的state\n  - payload是该方法在被调用时传递参数使用的\n```\n<!-- index.js -->\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n\nconst store = new Vuex({\n    state:{\n        name:'helloVueX'\n    },\n    mutations:{\n        //es6语法，等同edit:funcion(){...}\n        edit(state){\n            state.name = 'jack'\n        }\n    }\n})\n\nexport default store\n```\n而在组件中，我们需要这样去调用这个mutation——例如在App.vue的某个method中:\n```\nthis.$store.commit('edit')\n```\n\n### Mutation传值 ###\n在实际生产过程中，会遇到需要在提交某个mutation时需要携带一些参数给方法使用。\n单个值提交时:\n```\nthis.$store.commit('edit',15)\n```\n当需要多参提交时，推荐把他们放在一个对象中来提交:\n```\nthis.$store.commit('edit',{age:15,sex:'男'})\n```\n接收挂载的参数：\n```\nedit(state,payload){\n  state.name = 'jack'\n  console.log(payload) // 15或{age:15,sex:'男'}\n}\n```\n另一种提交方式\n```\nthis.$store.commit({\n    type:'edit',\n    payload:{\n        age:15,\n        sex:'男'\n    }\n})\n```\n### 增删state中的成员 ###\n为了配合Vue的响应式数据，我们在Mutations的方法中，应当使用Vue提供的方法来进行操作。\n如果使用delete或者xx.xx = xx的形式去删或增，则Vue不能对数据进行实时响应。\n\n  - Vue.set 为某个对象设置成员的值，若不存在则新增\n\n例如对state对象中添加一个age成员\n```\nVue.set(state,\"age\",15)\n```\n  - Vue.delete 删除成员\n\n将刚刚添加的age成员删除\n\n```\nVue.delete(state,'age')\n```\n###  Actions ###\n由于直接在mutation方法中进行异步操作，将会引起数据失效。所以提供了Actions来专门进行异步操作，最终提交mutation方法。\n\n**Actions中的方法有两个默认参数**\n\n  - context 上下文(相当于箭头函数中的this)对象\n  - payload 挂载参数\n\n由于`setTimeout`是异步操作，所以需要使用`actions`\n```\nactions:{\n    aEdit(context,payload){\n        setTimeout(()=>{\n            context.commit('edit',payload)\n        },2000)\n    }\n}\n```\n在组件中调用:\n```\nthis.$store.dispatch('aEdit',{age:15})\n```\n### Getters ###\n可以对state中的成员加工后传递给外界\n\n**Getters中的方法有两个默认参数**\n\n  - state 当前VueX对象中的状态对象\n  - getters 当前getters对象，用于将getters下的其他getter拿来用\n```\ngetters:{\n    nameInfo(state){\n        return \"姓名:\"+state.name\n    },\n    fullInfo(state,getters){\n        return getters.nameInfo+'年龄:'+state.age\n    }  \n}\n```\n或者\n```\nconst getters = {\n  loading: state => state.user.loading,\n  token: state => state.user.token,\n}\nexport default getters\n```\n组件中调用\n```\nthis.$store.getters.fullInfo\n```\n\n### Models ###\n当项目庞大，状态非常多时，可以采用模块化管理模式。Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 `state、mutation、action、getter、`甚至是嵌套子模块——从上至下进行同样方式的分割。\n```\nmodels:{\n    a:{\n        state:{},\n        getters:{},\n        ....\n    }\n}\n```\n组件内调用模块a的状态：\n```\nthis.$store.state.a\n```\n而提交或者`dispatch`某个方法和以前一样,会自动执行所有模块内的对应`type`的方法：\n```\nthis.$store.commit('editKey')\nthis.$store.dispatch('aEditKey')\n```\n### 模块的细节 ###\n  - 模块中`mutations`和`getters`中的方法接受的第一个参数是自身局部模块内部的`state`\n```\nmodels:{\n    a:{\n        state:{key:5},\n        mutations:{\n            editKey(state){\n                state.key = 9\n            }\n        },\n        ....\n    }\n}\n```\n  - `getters`中方法的第三个参数是根节点状态\n```\nmodels:{\n    a:{\n        state:{key:5},\n        getters:{\n            getKeyCount(state,getter,rootState){\n                return  rootState.key + state.key\n            }\n        },\n        ....\n    }\n}\n```\n  - `actions`中方法获取局部模块状态是`context.state`,根节点状态是`context.rootState`\n```\nmodels:{\n    a:{\n        state:{key:5},\n        actions:{\n            aEidtKey(context){\n                if(context.state.key === context.rootState.key){\n                    context.commit('editKey')\n                }\n            }\n        },\n        ....\n    }\n}\n```\n\n## store目录结构 ##\n![alt](/images/store.png)\n```\n<!-- index.js -->\nimport Vue from 'vue'\nimport Vuex from 'vuex'\nimport getters from './getters'\n\nimport user from './modules/user'\nimport aside from './modules/aside'\nimport homeTemp from './modules/homeTemp'\nimport homeNormal from './modules/homeNormal'\nimport homePage from './modules/homePage'\nVue.use(Vuex)\n\nconst store = new Vuex.Store({\n  getters,\n  modules: {\n    user,\n    aside,\n    homeTemp,\n    homeNormal,\n    homePage\n  }\n})\n\nexport default store\n```\n```\n<!-- getters.js -->\nconst getters = {\n  loading: state => state.user.loading,\n  token: state => state.user.token,\n  dialogMask: state => state.homeTemp.dialogMask,\n}\nexport default getters\n```\n```\n<!-- dialogMask.js -->\nconst dialogMask = {\n  state: {\n    dialogMask: false\n  },\n  mutations: {\n    SET_MASKDIALOG: (state, dialogMask) => {\n      state.dialogMask = dialogMask\n    }\n  },\n  actions: {\n    maskDialog ({ commit }, params) {\n      commit('SET_MASKDIALOG', params)\n    }\n  }\n}\n\nexport default dialogMask\n\n```\n组件内调用某个模块的状态\n```\nthis.$store.getters.dialogMask\n```\n组件内某个模块更改状态\n```\nthis.$store.dispatch('dialogMask', true)\n```\n或者\n```\nlet params = {'accountNo': this.loginForm.username, 'password': md5(this.loginForm.password)}\nthis.$store.dispatch('Login', params).then((res) => {\n  console.log(res)\n  localStorage.setItem('orgIds', res.data.data.orgId)\n  this.$router.push({ path: '/' })\n}).catch((err) => {\n  console.log(err)\n})\n```","tags":["vue"],"categories":["vue"]},{"title":"promise","url":"/promise/","content":"## promise介绍 ##\n1、主要用于异步计算\n2、可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果\n3、可以在对象之间传递和操作promise，帮助我们处理队列\n4、promise是一个对象，对象和函数的区别就是对象可以保存状态，函数不可以（闭包除外）\n5、并未剥夺函数return的能力，因此无需层层传递callback，进行回调获取数据\n6、代码风格，容易理解，便于维护\n7、多个异步等待合并便于解决\n\n\n<escape><!-- more --></escape>\n\n\n**promise有三个状态** \n  - pending[待定]初始状态\n  - fulfilled[实现]操作成功\n  - rejected[被否决]操作失败\n当promise状态发生改变，就会触发then()里的响应函数处理后续步骤；\npromise状态一经改变，不会再变。\n\n**Promise对象的状态改变，只有两种可能**\n  - 从pending变为fulfilled\n  - 从pending变为rejected\n\n**promise作为队列最为重要的特性，我们在任何一个地方生成了一个promise队列之后，我们可以把他作为一个变量传递到其他地方**\n\n## .then() ##\n1、接收两个函数作为参数，分别代表fulfilled（成功）和rejected（失败）\n2、.then()返回一个新的Promise实例，所以它可以链式调用\n3、当前面的Promise状态改变时，.then()根据其最终状态，选择特定的状态响应函数执行\n4、状态响应函数可以返回新的promise，或其他值，不返回值也可以我们可以认为它返回了一个null；\n5、如果返回新的promise，那么下一级.then()会在新的promise状态改变之后执行\n6、如果返回其他任何值，则会立即执行下一级.then()\n** 错误处理两种做法 **\n  - reject('错误信息').then(() => {}, () => {错误处理逻辑})\n  - throw new Error('错误信息').catch( () => {错误处理逻辑})\n## .catch() ##\ncatch也会返回一个promise实例，并且是resolved状态,会继续向下执行。\n如果抛出错误变为rejected状态，所以绕过两个then直接跑到最下面的catch\n![alt](/images/catch1.png)\n![alt](/images/catch1Result.png)\n![alt](/images/catch2.png)\n![alt](/images/catch2Result.png)\n## Demo ##\n```\nfunction fn1 () {\n    let p = new Promise((resolve,reject) => {\n        setTimeout(() => {\n            console.log('fn1函数')\n            // let num = Math.ceil(Math.random()*10)\n            let num =3\n            num < 5 ? resolve(num) : reject('数太大了')\n        },2000)\n    })\n    return p\n}\nfunction fn2 () {\n    let p = new Promise((resolve,reject) => {\n        setTimeout(() => {\n            console.log('fn2函数')\n            resolve('fn2执行下一个操作')\n        },2000)\n    })\n    return p\n}\nfunction fn3 () {\n    let p = new Promise((resolve,reject) => {\n        setTimeout(() => {\n            console.log('fn3函数')\n            resolve('fn3执行下一个操作')\n        },2000)\n    })\n    return p\n}\n```\n## then(()=> {}, ()=> {}).catch(()=>{}) ##\n```\n\nfn1().then((data) => {\n    console.log(data)\n    // console.log(dataparams)\n    return fn2()\n}, (err,data) => {\n    console.log(err)\n}).then((data)=> {\n    console.log(data)\n    return fn3()\n}).then((data)=>{\n    console.log(data)\n    return '直接返回数据'\n}).then((data)=>{\n    console.log(data)\n    return data\n}).catch(function(reason){\n    console.log('rejected');\n    console.log(reason);\n});\n```\n## Promise.all([]).then(()=>{}) ##\n```\n// '谁跑的慢，以谁为准执行回调'\n// '谁跑的慢，以谁为准执行回调'\n// 使用场景 所有的异步操作执行结束 在执行then\n\nPromise\n.all([fn1(), fn2(), fn3()])\n.then(function(results){\n    console.log(results);\n});\n```\n## Promise.race([]).then(()=>{}) ##\n```\n// '谁跑的快，以谁为准执行回调'\n// 使用场景\n//请求某个图片资源\nfunction requestImg(){\n    var p = new Promise(function(resolve, reject){\n        var img = new Image();\n        img.onload = function(){\n            resolve(img);\n        }\n        img.src = 'xxxxxx';\n    });\n    return p;\n}\n\n//延时函数，用于给请求计时\nfunction timeout(){\n    var p = new Promise(function(resolve, reject){\n        setTimeout(function(){\n            reject('图片请求超时');\n        }, 5000);\n    });\n    return p;\n}\nPromise\n.race([requestImg(), timeout()])\n.then(function(results){\n    console.log(results);\n});\n```\n","tags":["ES6"],"categories":["ES6"]},{"title":"vue-router","url":"/vue-router/","content":"## 路由传参 ##\n### 定义vue-router的动态路由 ###\n\n| 声明式               | 编程式                     |\n| ------------------ | ------------------------ |\n| `<router-link :to=\"...\">` | `router.push(...)` |\n\n路由中设置多段`路径参数`，对应的值都会设置到 `$route.params` 中。例如：\n\n| 模式                | 匹配路径                 |$route.params            |\n| ------------------ | ------------------------ |------------------------ |\n| /user/:username    | /user/evan               | { username: 'evan' }    |\n| /user/:username/post/:post_id    | /user/evan/post/123               | { username: 'evan', post_id: '123' }    |\n\n\n<escape><!-- more --></escape>\n\n\n携带参数的路由实现方式\n\n```\n// 对象\nrouter.push({ name: 'home' })\n\n// 带查询参数，变成 /register?plan=private\nrouter.push({ path: 'register', query: { plan: 'private' }})\n\n// -> /user/123\nrouter.push({ path: `/user/${userId}` }) \n\n// -> /user/123\nrouter.push({ name: 'user', params: { userId }}) \n```\n注意：如果提供了 `path，params` 会被忽略，上述例子中的 `query` 并不属于这种情况。\n\n### 获取传过来的动态参数 ###\n如果 在router目录下的path属性加上`/:id`，则使用router对象的`params.id`\n\n```\nthis.$route.params.id\nthis.$route.query.name\n```\n\n## 路由懒加载及嵌套 ##\n`require.ensure()`和`import()` 使用区分\n### require.ensure（）接受三个参数 ###\n\n第一个参数的依赖关系是一个数组，代表了当前需要进来的模块的一些依赖;\n\n第二个参数回调就是一个回调函数其中需要注意的是，这个回调函数有一个参数要求，通过这个要求就可以在回调函数内动态引入其他模块值得注意的是，虽然这个要求是回调函数的参数，理论上可以换其他名称，但是实际上是不能换的，否则的的的的WebPack就无法静态分析的时候处理它;\n\n第三个参数errorCallback比较好理解，就是处理错误的回调;\n\n第四个参数chunkName则是指定打包的组块名称。\n\n![alt](/images/ensure.png)\n\n### import() ###\n这个的进口不同于模块引入时的导入，可以理解为一个动态加载的模块的函数（函数等），传入其中的参数就是相应的模块\n![alt](/images/import.png)\n\n### index.js ###\n![alt](/images/index.png)\n\n## route router 的区别 ##\n`$route`对象表示当前的路由信息，包含了当前 URL 解析得到的信息。\n包含当前的路径，参数，query对象等。\n![alt](/images/route.png)\n\n```\n1.$route.path**      字符串，对应当前路由的路径，总是解析为绝对路径，如\"/foo/bar\"。\n\n2.$route.params**      一个 key/value 对象，包含了 动态片段 和 全匹配片段，      如果没有路由参数，就是一个空对象。\n\n3.$route.query**      一个 key/value 对象，表示 URL 查询参数。      例如，对于路径 /foo?user=1，则有$route.query.user == 1，      如果没有查询参数，则是个空对象。\n\n4.$route.hash**      当前路由的hash值 (不带#) ，如果没有 hash 值，则为空字符串。锚点*\n\n5.$route.fullPath**      完成解析后的 URL，包含查询参数和hash的完整路径。\n\n6.$route.matched**      数组，包含当前匹配的路径中所包含的所有片段所对应的配置参数对象。\n\n7.$route.name    当前路径名字\n\n8.$route.meta  路由元信息\n```\n`$router`对象是全局路由的实例，是`router`构造方法的实例。\n![alt](/images/router.png)\n\n```\n1. push方法\n2. go\n  页面路由跳转 \n  前进或者后退this.$router.go(-1)  // 后退\n3、replace\npush方法会向 history 栈添加一个新的记录，而replace方法是替换当前的页面，\n不会向 history 栈添加一个新的记录\n// 一般使用replace来做404页面\n\nthis.$router.replace('/')\n\n配置路由时path有时候会加 '/' 有时候不加,以'/'开头的会被当作根路径，就不会一直嵌套之前的路径。\n```","tags":["vue"],"categories":["vue"]},{"title":"ES6常用方方法","url":"/ES6常用方方法/","content":"\n\n<escape><!-- more --></escape>\n\n","tags":["vue","ES6"],"categories":["ES6"]},{"title":"vue项目结构","url":"/vue项目结构/","content":"## 一、目录结构 ##\n\n![alt](/images/vueTree.png)\n\n\n<escape><!-- more --></escape>\n\n\n## 二、结构细分 ##\n\n### build——[webpack配置] ###\nbuild文件主要是webpack的配置，主要启动文件是dev-server.js，当我们输入npm run dev首先启动的就是dev-server.js，它会去检查node及npm版本，加载配置文件，启动服务。\n\n![alt](/images/buildTree.png)\n\n### config——[vue项目配置] ###\n\nconfig文件主要是项目相关配置，我们常用的就是当端口冲突时配置监听端口，打包输出路径及命名等\n\n![alt](/images/configTree.png)\n \n### node_modules——[依赖包] ###\n\nnode_modules里面是项目依赖包，其中包括很多基础依赖，自己也可以根据需要安装其他依赖。安装方法为打开cmd，进入项目目录，输入npm install [依赖包名称],回车。\n\n在两种情况下我们会自己去安装依赖：\n\n（1）项目运行缺少该依赖包：例如项目加载外部css会用到的css-loader，路由跳转vue-loader等（安装方法示例：npm install css-loader）\n\n（2）安装插件：如vux（基于WEUI的移动端组件库），vue-swiper（轮播插件\n\n注：有时会安装指定依赖版本，需在依赖包名称后加上版本号信息，如安装11.1.4版本的vue-loader，输入npm install vue-loader@11.1.4\n\n### src——[项目核心文件]  ###\n![alt](/images/srcTree.png)\n\n### static——[静态资源文件]  ###\n![alt](/images/staticTree.png)","tags":["vue"],"categories":["vue"]},{"title":"vue脚手架搭建","url":"/vue脚手架搭建/","content":"## 一、安装 node.js ##\n\n## 二、安装 vue-cli ##\n\n```\n$ npm install -g vue-cli\n```\n```\n$ npm install -g cnpm --registry=https://registry.npm.taobao.org\n$ cnpm install -g vue-cli\n```\nvue-cli安装常遇到的问题\n\n```\n在node环境下搜索vue.cmd位置，配置环境变量\n```\n\n\n<escape><!-- more --></escape>\n\n\n## 三、生成项目 ##\n\n```\n$ vue init webpack [Vue-Project]\n```\n## 四、安装依赖 ##\n\n```\n$ cd [Vue-Project]\n$ cnpm install\n```\n## 五、启动项目 ##\n\n```\n$ npm run dev\n```\n## 六、安装sass依赖包 ##\n\n```\n1.安装sass\n$ npm install --save-dev node-sass\n$ npm install --save-dev sass-loader\n\n2.在build文件夹下的webpack.base.conf.js的rules里面添加配置\n{\n    test: /\\.scss$/, loaders: ['style', 'css', 'sass']\n}\n3.在APP.vue中修改style标签\n\n<style lang=\"scss\"></style>\n```\n## 七、rem的使用 ##\n\n```\nindex.html文件中引入\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    // <script src=\"http://g.tbcdn.cn/mtb/lib-flexible/0.3.4/??flexible_css.js,flexible.js\"></script>\n \nmixin.scss文件中引入\n \n    @function px_rem($px, $base-font-size: 37.5px) {\n      @return ($px / $base-font-size) * 1rem;\n    }\n\n在scss文件中使用\n    @import \"static/css/mixin.scss\";\n    h2{\n      height: px_rem(50px);\n    }\n```\n\n demo\n\n```\n<template>\n  <div id=\"DownLoadPage\">\n  </div>\n</template>\n<script>\nrequire('../utils/flexible.js')\nexport default {\n  name: 'DownLoadPage',\n  data () {\n    return {\n      \n    }\n  },\n  mounted () {\n   \n  },\n  computed: {\n   \n  }\n}\n</script>\n<style lang=\"scss\" scoped>\n@import 'src/assets/styles/mobile/mixin';\nhtml,body{\n  min-width: px_rem(320px);\n}\n</style>\n\n```\n \n## 八、element-ui的全局安装 ##\n\n```\n$ npm install element-ui  --save-dev\n```\n```\n整体引入\n在main.js中\nimport ElementUI from 'element-ui';\nimport 'element-ui/lib/theme-chalk/index.css';\n\nVue.use(ElementUI)\n```\n## 九、element-ui的按需安装 ##\n```\n按需引入element-ui\n$ npm install element-ui  --save-dev\n$ npm install babel-plugin-component -D\n```\n将 .babelrc 修改为：\n```\n{\n  \"presets\": [\n    [\"env\", {\n      \"modules\": false,\n      \"targets\": {\n        \"browsers\": [\"> 1%\", \"last 2 versions\", \"not ie <= 8\"]\n      }\n    }],\n    \"stage-2\",\n    [\"es2015\", { \"modules\": false }]\n  ],\n  \"plugins\": [\n    \"transform-vue-jsx\", \n    \"transform-runtime\",\n    [\n      \"component\",\n      {\n        \"libraryName\": \"element-ui\",\n        \"styleLibraryName\": \"theme-chalk\"\n      }\n    ]\n  ]\n}\n```\n那么需要在 main.js 中写入以下内容：\n\n```\nimport { Button, Select } from 'element-ui'\nVue.prototype.$ELEMENT = { size: 'small' }\nVue.use(Button)\nVue.use(Select)\n```\n## 十、安装es2015 ##\n\n```\n$ npm install babel-preset-es2015 --save-dev\n```\n## 十一、全局安装echarts ##\n\n```\n$ npm install echarts --save-dev\n// 引入echarts\nimport echarts from 'echarts'\n\nVue.prototype.$echarts = echarts \n```\n## 十二、按需安装echarts ##\n\n```\n// 引入基本模板\nlet echarts = require('echarts/lib/echarts')\n// 引入柱状图组件\nrequire('echarts/lib/chart/bar')\n// 引入提示框和title组件\nrequire('echarts/lib/component/tooltip')\nrequire('echarts/lib/component/title')\nexport default {\n  name: 'hello',\n  data() {\n    return {\n      msg: 'Welcome to Your Vue.js App'\n    }\n  },\n  mounted() {\n    this.drawLine();\n  },\n  methods: {\n    drawLine() {\n      // 基于准备好的dom，初始化echarts实例\n      let myChart = echarts.init(document.getElementById('myChart'))\n      // 绘制图表\n      myChart.setOption({\n        title: { text: 'ECharts 入门示例' },\n        tooltip: {},\n        xAxis: {\n          data: [\"衬衫\", \"羊毛衫\", \"雪纺衫\", \"裤子\", \"高跟鞋\", \"袜子\"]\n        },\n        yAxis: {},\n        series: [{\n          name: '销量',\n          type: 'bar',\n          data: [5, 20, 36, 10, 10, 20]\n        }]\n      });\n    }\n  }\n}\n```\n## 十三、数据状态管理 ##\n\n```\n$ npm install vuex --save\n\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n\nVue.use(Vuex)\n```\n## 十四、http服务模块 ##\n\n```\n$ npm install axios --save-dev\n```\n## 十五、安装jquery ##\n\n```\n$ npm install jquery --save-dev\n配置webpack.base.conf.js\n在module.exports中添加一段代码，\n// 原有代码\nresolve: {\n  extensions: ['.js', '.vue', '.json'],\n  alias: {\n    'vue$': 'vue/dist/vue.esm.js',\n    '@': resolve('src')\n  }\n},\n// 添加代码\nplugins: [\n  new webpack.ProvidePlugin({\n    $: \"jquery\",\n    jQuery: \"jquery\",\n    jquery: \"jquery\",\n    \"window.jQuery\": \"jquery\"\n  })\n],\n// 原有代码\nmodule: {\n  rules: [\n// ......\n  ]\n}\n```\n## 十六、vue-amap 高德地图 ##\n<https://elemefe.github.io/vue-amap/#/>\n```\n$ npm install vue-amap --save\n$ npm install geocoder\n打开webpack.base.conf.js文件，找到module.exports，在externals对象中加入一行：’AMap’: ‘AMap’\nexternals: {\n   'AMap': 'AMap',\n},\n配置.eslintrc.js全局的AMap\nglobals: {\n    \"AMap\":\"AMap\",\n  }\n在main.js中配置\nimport VueAMap from 'vue-amap'\n配置key值\nVueAMap.initAMapApiLoader({\n  key: 'a83c56afba46482fd8fba666e27231c2',\n  plugin: ['AMap.Autocomplete', 'AMap.PlaceSearch', 'AMap.Scale', 'AMap.OverView', 'AMap.ToolBar', 'AMap.MapType', 'AMap.PolyEditor', 'AMap.CircleEditor'],\n  // 默认高德 sdk 版本为 1.4.4\n  v: '1.4.4'\n})\n创建一个vue文件\n<template>\n  <div id=\"app\">\n    <h3 class=\"title\">{{ msg }}</h3>\n    <div class=\"amap-wrapper\">\n      <el-amap class=\"amap-box\" :vid=\"'amap-vue'\"></el-amap>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  data () {\n    return {\n      msg: 'vue-amap向你问好！'\n    }\n  }\n}\n</script>\n\n<style>\n.amap-wrapper {\n  width: 100%;\n  height: 800px;\n}\n</style>\n```\n## 十七、适配低版本 ##\n\n```\n首先\n安装babel-polyfill \n$ npm install babel-polyfill --save-dev\n\n入口文件引用\n在main.js中引用 \nimport 'babel-polyfill'\n\nvue-cli 配置修改\n如果也是用了官方脚手架vue-cli，还需要在webpack.config.js配置文件中做各修改，用 \nmodule.exports = { \n  entry: { \n    app: [\"babel-polyfill\", \"./src/main.js\"] \n  } \n}; \n替代 \nmodule.exports = { \n  entry: { \n    app: './src/main.js' \n  } \n} \n如果有多配置可以在webpack.base.config.js修改\n```\n## 十九、分环境打包 ##\n\n```\n安装cross-env\n\n$ npm i --save-dev cross-env\nconfig文件夹下新建文件sit.env.js\n\nmodule.exports = {\n  NODE_ENV: '\"production\"',\n  ENV_CONFIG: '\"sit\"',\n  BASE_API: '\"https://api-sit\"'\n}\n修改项目package.json文件\n\nNODE_ENV最好都设成production，因为在utils.js只做了production一种判定，亲测不会影响各环境API参数\n\n\"scripts\": {\n  \"dev\": \"webpack-dev-server --inline --progress --config build/webpack.dev.conf.js\",\n  \"start\": \"npm run dev\",\n  \"build\": \"node build/build.js\",\n  \"build:test\": \"cross-env NODE_ENV=production env_config=test node build/build.js\",\n  \"build:pre\": \"cross-env NODE_ENV=production env_config=pre node build/build.js\",\n  \"build:prod\": \"cross-env NODE_ENV=production env_config=prod node build/build.js\"\n },\n修改config/index.js文件中build参数\n\n这里的参数会在build/webpackage.prod.conf.js中使用到\n\nbuild: {\n    // 添加test pre prod 三处环境的配制\n    prodEnv: require('./prod.env'),\n    testEnv: require('./test.env'),\n    // Template for index.html\n    index: path.resolve(__dirname, '../dist/index.html'),\n\n    // Paths\n    assetsRoot: path.resolve(__dirname, '../dist'),\n    assetsSubDirectory: 'static',\n    ...\n\n在webpackage.prod.conf.js中使用构建环境参数\n\n// 个性env常量的定义\n// const env = require('../config/prod.env')\nconst env = config.build[process.env.env_config+'Env']\n\n调整build/build.js\n\n删除process.env.NODE_ENV的赋值，修改spinner的定义，调整后的内容如下：\n\n'use strict'\nrequire('./check-versions')()\n// 注释掉的代码\n// process.env.NODE_ENV = 'production'\nconst ora = require('ora')\nconst rm = require('rimraf')\nconst path = require('path')\nconst chalk = require('chalk')\nconst webpack = require('webpack')\nconst config = require('../config')\nconst webpackConfig = require('./webpack.prod.conf')\n// 修改spinner的定义\n// const spinner = ora('building for production...')\nvar spinner = ora('building for ' + process.env.NODE_ENV + ' of ' + process.env.env_config+ ' mode...' )\nspinner.start()\n//更多的其它内容，不需要做任何调整的内容 ...\n```\n## 二十、登录 ##\n\n```\njs-cookie 一个轻量的JavaScript库来处理cookie\n```\n## 二十二 、svg图标的使用 ##\n<http://www.iconfont.cn/plus>\n```\n1. 安装\n$npm install vue-svg-icon --save-dev\n2. 将svg图片放入src/svg\n这里安利一个svg图片库iconfont\n\nsrc/svg路径暂时不可配置\n\n3. 在项目的main.js入口引入vue-svg-icon和需要使用的svg文件名（不需扩展名）\nimport Icon from 'vue-svg-icon/Icon.vue';\nVue.component('icon', Icon);\n\n4. 在网页中使用icon标签就可以啦！\n<icon name=\"chameleon\" scale=\"20\"></icon>\n```\n## 二十二、mock数据 ##\n<http://mockjs.com/>\n```\n$npm install mockjs\n```\n## 二十一、打包 ##\n避免出现空白页\n\n```\n第一种解决方案\n打开config文件夹下的index.js，build模块，修改\nassetsPublicPath 的值为 assetsPublicPath: './'\n\n第二种解决方案\n修改build文件夹下webpack.prod.conf.js中的output模块为\noutput: {\n    publicPath: './',\n    path: config.build.assetsRoot,\n    filename: utils.assetsPath('js/[name].[chunkhash].js'),\n    chunkFilename: utils.assetsPath('js/[id].[chunkhash].js')\n},\n\n执行$npm run build:prod\n```\n\n[避免背景图片路径出错解决方案](https://www.cnblogs.com/moqiutao/p/7496718.html \"避免背景图片路径出错解决方案\")\n\n```\n修改build文件夹下的utils.js代码为\nif (options.extract) {\n  return ExtractTextPlugin.extract({\n    use: loaders,\n    fallback: 'vue-style-loader',\n    publicPath: '../../'\n  })\n} else {\n  return ['vue-style-loader'].concat(loaders)\n}\n\n增加一行代码      publicPath: '../../'\n```\n## 二十二 vue cli打包文件优化工具 webpack-bundle-analyzer ##\n\n```\n在vue-cli中不需要配置  直接执行\n$ npm run build --report\n```\n\n```\n需要配置\n安装webpack-bundle-analyzer插件\n\n$ npm install webpack-bundle-analyzer -–save-dev\n\n在build/webpack.prod.config.js中添加配置\n\nif (config.build.bundleAnalyzerReport) {\n    const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;\n    webpackConfig.plugins.push(new BundleAnalyzerPlugin());\n}\n在package.json的scripts中添加配置\n\n“analyz”: “NODE_ENV=production npm_config_report=true npm run build”\n\n运行命令\n\n$ npm run analyz\n```\n## 二十三 字体 ##\n\n```\n$ npm install font-awesome\n```\n## 二十四 404页面跳转处理 ##\n\n```\n在新建文件夹 WEB-INF 下新建 web.xml 内容如下\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n\txsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee/web-app_2_5.xsd\"\n\tid=\"scplatform\" version=\"2.5\">\n\t\n\t<display-name>/</display-name>\n\t\n\t<error-page>\n\t   <error-code>404</error-code>\n\t   <location>/index.html</location>\n\t</error-page>\n\t\n</web-app>\n\n在webpack.prod.conf.js 中修改\nnew CopyWebpackPlugin([\n  {\n    from: path.resolve(__dirname, '../static'),\n    to: config.build.assetsSubDirectory,\n    ignore: ['.*']\n  },\n  {\n    from: path.resolve(__dirname, '../WEB-INF'),\n    to: 'WEB-INF',\n    ignore: ['.*']\n  }\n])\n```\n","tags":["vue"],"categories":["vue"]},{"title":"layui前言","url":"/layui前言/","content":"\n\n<escape><!-- more --></escape>\n\n","tags":["layui"],"categories":["layui"]},{"title":"hexo-指令","url":"/hexo-指令/","content":"## init ##\n\n```\n$ hexo init [folder]\n```\n\n新建一个网站。如果没有设置 `folder` ，Hexo 默认在目前的文件夹建立网站。\n\n\n<escape><!-- more --></escape>\n\n\n## new ##\n\n```\n$ hexo new [layout] <title>\n```\n\n新建一篇文章。如果没有设置 `layout` 的话，默认使用 _config.yml中的 `default_layout` 参数代替。如果标题包含空格的话，请使用引号括起来。\n\n```\n$ hexo new \"post title with whitespace\"\n```\n\n| 参数              | 描述                                          |\n| ----------------- | --------------------------------------------- |\n| `-p`, `--path`    | 自定义新文章的路径                            |\n| `-r`, `--replace` | 如果存在同名文章，将其替换                    |\n| `-s`, `--slug`    | 文章的 Slug，作为新文章的文件名和发布后的 URL |\n\n默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 `index.md` 文件。你可以使用 `--path` 参数来覆盖上述行为、自行决定文件的目录：\n\n```\nhexo new page --path about/me \"About me\"\n```\n\n以上命令会创建一个 `source/about/me.md` 文件，同时 Front Matter 中的 title 为 `\"About me\"`\n\n注意！title 是必须指定的！如果你这么做并不能达到你的目的：\n\n```\nhexo new page --path about/me\n```\n\n此时 Hexo 会创建 `source/_posts/about/me.md`，同时 `me.md` 的 Front Matter 中的 title 为 `\"page\"`。这是因为在上述命令中，hexo-cli 将 `page` 视为指定文章的标题、并采用默认的 `layout`。\n\n## 创建新文章 ##\n\n根目录命令行输入 `hexo new <模板> <文章名>`新建文章\n\n其中<模板>在scaffolds中，默认情况下有三个模板post、draft、page\n\n| 参数  | 功能                           | 路径  |\n| ----- | ------------------------------ | ----- |\n| post  | 新建文章                        | /source/_posts/  |\n| draft | 新建草稿                        | /source/_drafts/ |\n| page  | 新建页面（标签页，分类页等）      | /source/ |\n\n通常情况下使用\n\n```\nhexo new post <title>\n```\n\n即可，注意这里的`title`不是文章名，具体文章中显示的文章标题可以在文章文件中修改，例如：我这里新建一篇文章，title为article\n\n命令行输入\n```\n$hexo new post article\n```\n此时在source/_posts/文件夹中多了一个article.md文件。\n\n## 给文章添加分类和模板 ##\n\n通过对文件头部配置信息中`tags` 与`categories`项的修改可以设置文章的标签及分类。\n\n其中标签可以按格式贴现设置多个：\n\n```\ntitle: Hexo博客新建文章并发布\ndate: 2018-12-06 12:16:12\ntags:\n - Hexo\n - Markdown\ncategories: 搭建博客\n```\n\n## generate ##\n\n```\n$ hexo generate\n```\n\n生成静态文件。\n\n| 选项                  | 描述                                                         |\n| --------------------- | ------------------------------------------------------------ |\n| `-d`, `--deploy`      | 文件生成后立即部署网站                                       |\n| `-w`, `--watch`       | 监视文件变动                                                 |\n| `-b`, `--bail`        | 生成过程中如果发生任何未处理的异常则抛出异常                 |\n| `-f`, `--force`       | 强制重新生成文件<br>Hexo 引入了差分机制，如果 `public` 目录存在，那么 `hexo g` 只会重新生成改动的文件。<br>使用该参数的效果接近 `hexo clean && hexo generate` |\n| `-c`, `--concurrency` | 最大同时生成文件的数量，默认无限制                           |\n\n该命令可以简写为\n\n```\n$ hexo g\n```\n\n## publish ##\n\n```\n$ hexo publish [layout] <filename>\n```\n\n发表草稿。\n\n## server ##\n\n```\n$ hexo server\n```\n\n启动服务器。默认情况下，访问网址为： `http://localhost:4000/`。\n\n| 选项             | 描述                           |\n| ---------------- | ------------------------------ |\n| `-p`, `--port`   | 重设端口                       |\n| `-s`, `--static` | 只使用静态文件                 |\n| `-l`, `--log`    | 启动日记记录，使用覆盖记录格式 |\n\n## deploy ##\n\n```\n$ hexo deploy\n```\n\n部署网站。\n\n| 参数               | 描述                     |\n| ------------------ | ------------------------ |\n| `-g`, `--generate` | 部署之前预先生成静态文件 |\n\n该命令可以简写为：\n\n```\n$ hexo d\n```\n\n## render ##\n\n```\n$ hexo render <file1> [file2] ...\n```\n\n渲染文件。\n\n| 参数             | 描述         |\n| ---------------- | ------------ |\n| `-o`, `--output` | 设置输出路径 |\n\n## migrate ##\n\n```\n$ hexo migrate <type>\n```\n\n从其他博客系统 [迁移内容](https://hexo.io/zh-cn/docs/migration \"迁移内容\")\n\n## clean ##\n\n```\n$ hexo clean\n```\n\n清除缓存文件 (`db.json`) 和已生成的静态文件 (`public`)。\n\n在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。\n\n## list ##\n\n```\n$ hexo list <type>\n```\n\n列出网站资料。\n\n## version ##\n\n```\n$ hexo version\n```\n\n显示 Hexo 版本。\n\n## 选项 ##\n\n### 安全模式 ###\n\n```\n$ hexo --safe\n```\n\n在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。\n\n### 调试模式 ###\n\n```\n$ hexo --debug\n```\n\n在终端中显示调试信息并记录到 `debug.log`。当您碰到问题时，可以尝试用调试模式重新执行一次，并 [提交调试信息到 GitHub](https://github.com/hexojs/hexo/issues/new)。\n\n### 简洁模式 ###\n\n```\n$ hexo --silent\n```\n\n隐藏终端信息。\n\n### 自定义配置文件的路径 ###\n\n```\n# 使用 custom.yml 代替默认的 _config.yml\n$ hexo server --config custom.yml\n\n# 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高\n$ hexo generate --config custom.yml,custom2.json,custom3.yml\n```\n\n自定义配置文件的路径，指定这个参数后将不再使用默认的 `_config.yml`。\n你可以使用一个 YAML 或 JSON 文件的路径，也可以使用逗号分隔（无空格）的多个 YAML 或 JSON 文件的路径。例如：\n\n```\n# 使用 custom.yml 代替默认的 _config.yml\n$ hexo server --config custom.yml\n\n# 使用 custom.yml, custom2.json 和 custom3.yml，其中 custom3.yml 优先级最高，其次是 custom2.json\n$ hexo generate --config custom.yml,custom2.json,custom3.yml\n```\n\n当你指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 `_multiconfig.yml`。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。\n\n### 显示草稿 ###\n\n```\n$ hexo --draft\n```\n\n显示 `source/_drafts` 文件夹中的草稿文章。\n\n### 自定义 CWD ###\n\n```\n$ hexo --cwd /path/to/cwd\n```\n\n自定义当前工作目录（Current working directory）的路径。\n\n","tags":["hexo"],"categories":["hexo"]},{"title":"Hexo 的 Next 主题优化一","url":"/Hexo-的-Next-主题优化一/","content":"\n\n<escape><!-- more --></escape>\n\n","tags":["hexo"],"categories":["hexo"]},{"title":"用Hexo和GitHub Pages 搭建博客","url":"/用Hexo和GitHub-Pages-搭建博客/","content":"**声明：转载**[https://ryanluoxu.github.io/2017/11/24/用-Hexo-和-GitHub-Pages-搭建博客/](https://ryanluoxu.github.io/2017/11/24/用-Hexo-和-GitHub-Pages-搭建博客/ \"Ryan Luo Xu 罗旭\")\n\n搭建这个博客走了许多弯路。在这里分享总结之后的思路和简化步骤。\n\n  - Github Pages\n  - Hexo 博客框架\n  - 部署\n  - Next 主题\n\n\n<escape><!-- more --></escape>\n\n\n## Github Pages ##\nGithub Pages 其实本身就是 Github 提供的博客服务。 我们在 Github 中创建一个特定格式的 Repository，Github Pages 就会将里面的信息生成一个网页，展示出来。\n\n**操作如下：**\n\n  1. 注册 Github 账号，然后在 Github 中创建一个以 .github.io 结尾的 Repository。\n\t1. Repository name: xxx.github.io\n\t2. 勾选 Initialize this repository with a README\n\t3. Create repository\n  1. 简单地编辑一下 README.md 这个文档。 比如添加：I am trying to create my own blog.. 保存(Commit changes)。\n  2. 打开网页：xxx.github.io 这里就可以看到 README.md 里的内容了。\n  \n如果没有太多的要求，其实直接用 README.md 来写博客也是不错的。\n\n这个生成好的 Repository 就是用来存放博客内容的地方，也只有这个仓库里的内容，才会被 xxx.github.io 这个网页显示出来。\n\n## Hexo ##\nHexo 是一个博客框架。它把本地文件里的信息生成一个网页。如果不需要放在网上给别人看，就没 Github Pages 什么事了。\n\n使用 Hexo 之前，需要先安装 Node.js 和 Git。\n\n**操作如下：**\n\n1. 安装 Node.js\n\t\n\t- 前往[https://nodejs.org/en/](https://nodejs.org/en/ \"node官网\")\n\t- 点击 8.9.1 LTS 下载\n\t- 安装\n\t- 打开 Command Prompt， 输入 node -v\n\t- 得到：v8.9.1\n\t\n\t安装成功\n\n2. 安装 Git\n\n\t- 前往 [https://git-scm.com/](https://git-scm.com/)\n\t- 点击 Downloads\n\t- 点击 Windows\n\t- 一般情况，下载会自动开始。如果没有，就点击 click here to download manually\n\t- 安装\n\t- 打开 Command Prompt， 输入 git --version\n\t- 得到：git version 2.15.0.windows.1\n\t\n\t安装成功\n\t\n\t额外说明：如果 Git –version 指令不管用，可能需要到 Environment Variable 那里添加 Path。\n\n3. 安装 Hexo\n\n\t- 打开 Command Prompt\n\t- 输入 npm install -g hexo-cli\n\t- 回车开始安装\n\t- 输入 hexo -v\n\t- 得到 hexo-cli: 1.0.4 等一串数据\n\n\t安装成功\n\n4. 创建本地博客\n\n\t- 在D盘下创建文件夹 blog\n\t- 鼠标右键 blog，选择 Git Bash Here。 如果没有安装 Git，就不会有这个选项。\n\t- Git Bash 打开之后，所在的位置就是 blog 这个文件夹的位置。（/d/blog）\n\t- 输入 hexo init 将 blog 文件夹初始化成一个博客文件夹。\n\t- 输入 npm install 安装依赖包。\n\t- 输入 hexo g 生成（generate）网页。 由于我们还没创建任何博客，生成的网页会展示 Hexo 里面自带了一个 Hello World 的博客。\n\t- 输入 hexo s 将生成的网页放在了本地服务器（server）。\n\t- 浏览器里输入 http://localhost:4000/ 。 就可以看到刚才的成果了。\n\t- 回到 Git Bash，按 Ctrl+C 结束。\n\n\t此时再看 http://localhost:4000/ 就是无法访问了。\n\n5. 发布一篇博客\n\n\t- 继续在 Git Bash 里，所在路径还是 /d/blog。输入 hexo new \"My First Post\"\n\t- 在 D:\\blog\\source_posts 路径下，会有一个 My-First-Post.md 的文件。 编辑这个文件，然后保存。\n\t- 回到 Git Bash，输入 hexo g\n\t- 输入 hexo s\n\t- 前往 http://localhost:4000/ 查看成果。\n\t- 回到 Git Bash，按 Ctrl+C 结束。\n\t\n## 将本地 Hexo 博客部署在 Github 上 ##\n前面两个部分，我们已经有了本地博客，和一个能托管这些资料的线上仓库。只要把本地博客部署（deploy）在我们的 Github 对应的 Repository 就可以了。\n\n**操作如下：**\n\n1. 获取 Github 对应的 Repository 的链接。\n\n\t- 登陆 Github，进入到 ryanluoxu.github.io\n\t- 点击 Clone or download\n\t- 复制 URL 待用\n\n\t我的是 https://github.com/xxx/xxx.github.io.git\n\n2. 修改博客的配置文件\n\n\t- 打开配置文件 /d/blog/_config.yml （使用 bash 里的 vi 或者 notepad++）\n\t- 找到 #Deployment，填入以下内容：\n\t\n\t```\n\tdeploy:  \n\t      type: git  \n\t      repository: https://github.com/xxx/xxx.github.io.git  \n\t      branch: master\n\t```\n\t或\n\t```\n\tdeploy:  \n\t      type: git  \n\t      repository: git@github.com:xxx/xxx.github.io.git  \n\t      branch: master\n\t```\n\thttps模式每次部署需要输入账号和密码，git模式的不需要\n\n3. 部署\n\t\n\t- 回到 Git Bash\n\t- 输入 npm install hexo-deployer-git --save 安装 hexo-deployer-git 此步骤只需要做一次。\n\t- 输入 hexo d\n\t- 得到 INFO Deploy done: git 即为部署成功\n\n\t之前我们创建的 ReadMe.md 会被自动覆盖掉。\n\n\n4. 查看成果\n\n\t前往 xxx.github.io 即可。\n\n## 使用 Next 主题 ##\n[https://hexo.io/themes/](https://hexo.io/themes/ \"查看更多主题\")\n\n这里以 Next 为例。 大概思路就是把整个主题的文件克隆到我们的主题文件夹中。在配置文件中注明使用该主题。\n\n**操作如下：**\n\n1. 还是回到 Git Bash。 输入 git clone https://github.com/iissnan/hexo-theme-next themes/next\n\n\t这样，该主题的文件就全部克隆到 D:\\blog\\themes\\next 下面。\n\n2. 修改博客配置文件\n\t- 打开 D:\\blog_config.yml\n\t- 找到 theme:\n\t- 把 Hexo 默认的 lanscape 修改成 next。 即 theme: next\n\t- 找到 # Site，添加博客名称，作者名字等。\n\t- 在 language 后面填入 en 或者 zh-Hans，选择英文或者中文。\n\t- 找到 # URL, 填入 url。比如 url: https://xxx.github.io\n\t\n\t填入名字后会有很风骚的 © 2017 xxx 的字样出现在博客底部。\n\n3. 重新生成部署即可\n\n\t- 回到 Git Bash。输入 hexo g -d就可以了。\n\n\t先把修改的内容生成网页，再部署。\n\n4. 查看成果\n\n\t前往 xxx.github.io 即可。","tags":["hexo"],"categories":["hexo"]},{"title":"Hello World","url":"/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n\n<escape><!-- more --></escape>\n\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","tags":["hexo"],"categories":["hexo"]}]